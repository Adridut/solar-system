<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Solar System</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>

<body>

<script src="js/three.min.js"></script>
<!-- Einbinden der OrbitControls, um die Darstellung mit der Maus rotieren zu kÃ¶nnen. -->

<script src="js/OrbitControls.js"></script>

<div id="container"></div>
<!-- Buttons. with 'position: absolute', the buttons stays in the image  -->
<div style="position: absolute">
    <button onclick="displayOrbits()">Orbits</button>
    <button onclick="displayAxis()">Axis</button>
    <button onclick="setLight()">Lights</button>
    <button onclick="setBackground()">Background</button>
    <button onclick="speedDown()">- Speed</button>
    <button onclick="speedUp()">+ Speed</button>
    <div style="color: aqua" id='seconds-counter'></div>
    <div style="color: aqua" id='track'></div>
    <div style="color: yellow" id='pn'></div>
</div>

<script>

    //1st
    //TODO Clean Up
    //TODO onClick
    //TODO Improve time representation/modification
    //TODO Buttons to change planets sizes and distances
    //TODO distances/sizes
    //TODO Open/Close buttons menu
    //TODO Axis position
    //TODO Sun glow
    //TODO remove earth night map from list and use earth.add(nightmap)
    //TODO update textures

    //2nd
    //TODO Matching color orbits
    //TODO Add the Moon

    //3rd
    //TODO Dwarf planets and satelites
    //TODO Asteroide belt

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var controls = new THREE.OrbitControls(camera, renderer.domElement);

    var x = 0;
    var y = 0;
    var z = 400;

    camera.position.set(x, y, z);
    camera.lookAt(0, 0, 0);
    controls.update();

    var planetDistanceFromSun = 1 / 2;
    var planetSize = 1 / 2;
    var sunSize = 0.5;
    var earthSize = 1;
    var time = 0.01;

    g = 6.6743e-11;
    s = 26 * time;
    sX = 26 * time;
    sZ = 26 * time;

    // 1 second = 1 day
    var speedAdjustment = 0.105;
    var rotationAjustment = 0.11;
    //O.541 * days = rotation speed

    var seconds = 0;
    var modelTime = 0;
    var el = document.getElementById('seconds-counter');

    //Planets data
    var solarSystemData = [
        {
            name: "Neptune",
            texture: './textures/neptunemap.jpg',
            size: 7.7,
            position: -731.1,
            speed: 60190.03,
            rotation: 0.671,
            mass: 1.02413*10^26,
            id: 8
        },
        {
            name: "Uranus",
            texture: './textures/uranusmap.jpg',
            size: 10,
            position: -604.6,
            speed: 30687.15,
            rotation: -0.718,
            mass: 8.6810*10^25,
            id: 7,
            ringTexture: './textures/uranusringcolour.jpg',
            ringTrans:'./textures/uranusringtrans.gif'
        },
        {
            name: "Saturn",
            texture: './textures/saturnmap.jpg',
            size: 23.4,
            position: -474.2,
            speed: 10755.70,
            rotation: 0.437,
            mass: 5.6834*10^26,
            id: 6,
            ringTexture: './textures/saturnringcolor.jpg',
            ringTrans: './textures/saturnringpattern.gif'
        },
        {
            name: "Jupiter",
            texture: './textures/jupitermap.jpg',
            size: 28.5,
            position: -379.1,
            // position: 778340000,
            speed: 4332.82,
            rotation: 0.423,
            mass: 1.8982*10^27,
            id: 5,
            dValue: 1.496 * Math.pow(10, 11),
            dSpeed: 0,
            aValue: Math.PI / 6,
            aSpeed: 1.990986 *  Math.pow(10, -7)
        },
        {
            name: "Mars",
            texture: './textures/marsmap.jpg',
            bump: './textures/marsbump.jpg',
            size: 1.4,
            position: -312.4,
            speed: 686.98,
            rotation: 1.02,
            mass: 6.4171 * 10^23,
            id: 4
        },
        {
            name: "EarthNightMap",
            texture: './textures/earthlights.jpg',
            bump: './textures/earthbump.jpg',
            size: 2.6 * earthSize,
            position: -303.2,
            speed: 365.26,
            mass: 5.97237 * 10^24,
            rotation: 1
        },
        {
            name: "Earth",
            texture: './textures/earthmap.jpg',
            bump: './textures/earthbump.jpg',
            size: 2.6 * earthSize,
            position: -303.2 + (earthSize * planetSize) / 10, //A value is added to separate the two earth maps
            speed: 365.26,
            rotation: 1,
            mass: 5.97237 * 10^24,
            id: 3
        },
        {
            name: "Venus",
            texture: './textures/venusmap.jpg',
            bump: './textures/venusbump.jpg',
            size: 2.5,
            position: -295.3,
            speed: 224.7,
            rotation: -243.02,
            mass: 4.8675 * 10^24,
            id: 2
        },
        {
            name: "Mercury",
            texture: './textures/mercurymap.jpg',
            bump: './textures/mercurybump.jpg',
            size: 1.0,
            position: -288.41,
            speed: 87.97,
            rotation: 58.55,
            mass: 3.3011 * 10^23,
            id: 1
        },
        {
            name: "Sun",
            texture: './textures/sunmap.jpg',
            size: 283.4 * sunSize,
            position: 0,
            rotation: 26,
            mass: 1.9885*10^30,
            id: 0
        }
    ];

    var solarSystem = new Array(9);


    //Creating planets
    for (i = 0; i < solarSystemData.length; i++) {
        var planet = solarSystemData[i];
        solarSystem[i] = createPlanet(planet);
        scene.add(solarSystem[i]);
    }

    //Add earth clouds
    solarSystem[6].add(createEarthClouds());


    _RingGeometry = function ( innerRadius, outerRadius, thetaSegments ) {

        THREE.Geometry.call( this );

        innerRadius	= innerRadius || 0;
        outerRadius	= outerRadius || 50;
        thetaSegments	= thetaSegments	|| 8;

        var normal	= new THREE.Vector3( 0, 0, 1 );

        for(var i = 0; i < thetaSegments; i++ ){
            var angleLo	= (i / thetaSegments) *Math.PI*2;
            var angleHi	= ((i+1) / thetaSegments) *Math.PI*2;

            var vertex1	= new THREE.Vector3(innerRadius * Math.cos(angleLo), innerRadius * Math.sin(angleLo), 0);
            var vertex2	= new THREE.Vector3(outerRadius * Math.cos(angleLo), outerRadius * Math.sin(angleLo), 0);
            var vertex3	= new THREE.Vector3(innerRadius * Math.cos(angleHi), innerRadius * Math.sin(angleHi), 0);
            var vertex4	= new THREE.Vector3(outerRadius * Math.cos(angleHi), outerRadius * Math.sin(angleHi), 0);

            this.vertices.push( vertex1 );
            this.vertices.push( vertex2 );
            this.vertices.push( vertex3 );
            this.vertices.push( vertex4 );


            var vertexIdx	= i * 4;

            // Create the first triangle
            var face = new THREE.Face3(vertexIdx + 0, vertexIdx + 1, vertexIdx + 2, normal);
            var uvs = [];

            var uv = new THREE.Vector2(0, 0);
            uvs.push(uv);
            var uv = new THREE.Vector2(1, 0);
            uvs.push(uv);
            var uv = new THREE.Vector2(0, 1);
            uvs.push(uv);

            this.faces.push(face);
            this.faceVertexUvs[0].push(uvs);

            // Create the second triangle
            var face = new THREE.Face3(vertexIdx + 2, vertexIdx + 1, vertexIdx + 3, normal);
            var uvs = [];

            var uv = new THREE.Vector2(0, 1);
            uvs.push(uv);
            var uv = new THREE.Vector2(1, 0);
            uvs.push(uv);
            var uv = new THREE.Vector2(1, 1);
            uvs.push(uv);

            this.faces.push(face);
            this.faceVertexUvs[0].push(uvs);
        }

        // this.computeCentroids();
        this.computeFaceNormals();

        this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), outerRadius );

    };
    _RingGeometry.prototype = Object.create( THREE.Geometry.prototype );

    createRing	= function(width, height, texture, trans, innerRadius, outerRadius){
        // create destination canvas
        var canvasResult	= document.createElement('canvas');
        canvasResult.width	= width;
        canvasResult.height	= height;
        var contextResult	= canvasResult.getContext('2d');

        var imageMap	= new Image();
        imageMap.addEventListener("load", function() {

            var canvasMap	= document.createElement('canvas');
            canvasMap.width	= imageMap.width;
            canvasMap.height= imageMap.height;
            var contextMap	= canvasMap.getContext('2d');
            contextMap.drawImage(imageMap, 0, 0);
            var dataMap	= contextMap.getImageData(0, 0, canvasMap.width, canvasMap.height);

            var imageTrans	= new Image();
            imageTrans.addEventListener("load", function(){
                var canvasTrans		= document.createElement('canvas');
                canvasTrans.width	= imageTrans.width;
                canvasTrans.height	= imageTrans.height;
                var contextTrans	= canvasTrans.getContext('2d');
                contextTrans.drawImage(imageTrans, 0, 0);
                var dataTrans		= contextTrans.getImageData(0, 0, canvasTrans.width, canvasTrans.height);
                // merge dataMap + dataTrans into dataResult
                var dataResult		= contextMap.createImageData(canvasResult.width, canvasResult.height);
                for(var y = 0, offset = 0; y < imageMap.height; y++){
                    for(var x = 0; x < imageMap.width; x++, offset += 4){
                        dataResult.data[offset]	= dataMap.data[offset];
                        dataResult.data[offset+1]	= dataMap.data[offset+1];
                        dataResult.data[offset+2]	= dataMap.data[offset+2];
                        dataResult.data[offset+3]	= 255 - dataTrans.data[offset]/2
                    }
                }
                // update texture with result
                contextResult.putImageData(dataResult,0,0);
                material.map.needsUpdate = true;
            });
            imageTrans.src	= trans;
        }, false);
        imageMap.src	= texture;

        var geometry	= new _RingGeometry(innerRadius, outerRadius, 64);
        var material	= new THREE.MeshPhongMaterial({
            map		: new THREE.Texture(canvasResult),
            side		: THREE.DoubleSide,
            transparent	: true,
            opacity		: 0.8
        });
        var mesh	= new THREE.Mesh(geometry, material);
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        mesh.lookAt(new THREE.Vector3(0.5,-4,1));
        return mesh
    };

    solarSystem[1].add(createRing(1024, 72, solarSystemData[1].ringTexture, solarSystemData[1].ringTrans,
        solarSystemData[1].size - 1, solarSystemData[1].size - 3));

    solarSystem[2].add(createRing(915, 64, solarSystemData[2].ringTexture, solarSystemData[2].ringTrans,
        solarSystemData[2].size - 4, solarSystemData[2].size - 8));

    function createPlanet(p) {
        var img = new THREE.TextureLoader().load(p.texture);
        geometry = new THREE.SphereBufferGeometry(p.size * planetSize, 32, 32);
        if (p.name === "Sun" || p.name === "EarthNightMap") {
            material = new THREE.MeshBasicMaterial({map: img});
        } else {
            material = new THREE.MeshPhongMaterial({map: img});
        }

        //Bump for solid planets
        if (p.id <= 4 && p.id > 0) {
            material.bumpMap = THREE.ImageUtils.loadTexture(p.bump);
            material.bumpScale = planetSize / 30
        }

        //Specular for the Earth
        if (p.name === "Earth") {
            material.specularMap = THREE.ImageUtils.loadTexture('./textures/earthspec.jpg');
            material.specular = new THREE.Color('#222222'); //Color more dark => Less glowing
        }


        var planet = new THREE.Mesh(geometry, material);
        planet.receiveShadow = true;
        planet.castShadow = true;
        planet.position.set(p.position * planetDistanceFromSun, 0, 0);

        return planet
    }

    //Mostly took from http://jeromeetienne.github.io/threex.planets/examples/select.html#Earth
    function createEarthClouds() {

        // create destination canvas
        var canvasResult = document.createElement('canvas');
        canvasResult.width = 1024;
        canvasResult.height = 512;
        var contextResult = canvasResult.getContext('2d');

        // load earthcloudmap
        var imageMap = new Image();
        imageMap.addEventListener("load", function () {

            // create dataMap ImageData for earthcloudmap
            var canvasMap = document.createElement('canvas');
            canvasMap.width = imageMap.width;
            canvasMap.height = imageMap.height;
            var contextMap = canvasMap.getContext('2d');
            contextMap.drawImage(imageMap, 0, 0);
            var dataMap = contextMap.getImageData(0, 0, canvasMap.width, canvasMap.height);

            // load earthcloudmaptrans
            var imageTrans = new Image();
            imageTrans.addEventListener("load", function () {
                // create dataTrans ImageData for earthcloudmaptrans
                var canvasTrans = document.createElement('canvas');
                canvasTrans.width = imageTrans.width;
                canvasTrans.height = imageTrans.height;
                var contextTrans = canvasTrans.getContext('2d');
                contextTrans.drawImage(imageTrans, 0, 0);
                var dataTrans = contextTrans.getImageData(0, 0, canvasTrans.width, canvasTrans.height);
                // merge dataMap + dataTrans into dataResult
                var dataResult = contextMap.createImageData(canvasMap.width, canvasMap.height);
                for (var y = 0, offset = 0; y < imageMap.height; y++) {
                    for (var x = 0; x < imageMap.width; x++, offset += 4) {
                        dataResult.data[offset] = dataMap.data[offset];
                        dataResult.data[offset + 1] = dataMap.data[offset + 1];
                        dataResult.data[offset + 2] = dataMap.data[offset + 2];
                        dataResult.data[offset + 3] = 255 - dataTrans.data[offset];
                    }
                }
                // update texture with result
                contextResult.putImageData(dataResult, 0, 0);
                cloudMaterial.map.needsUpdate = true;
            });
            imageTrans.src = './textures/earthcloudmaptrans.jpg';
        }, false);
        imageMap.src = './textures/earthcloudmap.jpg';

        var cloudGeometry = new THREE.SphereGeometry((2.6 * planetSize * earthSize), 32, 32);
        var cloudMaterial = new THREE.MeshPhongMaterial({
            map: new THREE.Texture(canvasResult),
            side: THREE.DoubleSide,
            opacity: 0.8,
            transparent: true,
            depthWrite: false
        });
        var cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
        return cloudMesh;
    }

    //Background
    var bgGeometry = new THREE.SphereGeometry(z * 1.2, 32, 32);
    var bgMaterial = new THREE.MeshBasicMaterial();
    bgMaterial.map = THREE.ImageUtils.loadTexture('./textures/starfield_bg4.png');
    bgMaterial.side = THREE.BackSide;
    var bg = new THREE.Mesh(bgGeometry, bgMaterial);

    var isBackgroundDisplay = 0;

    function setBackground() {
        if (isBackgroundDisplay === 0) {
            scene.add(bg);
            isBackgroundDisplay = 1;
        } else {
            scene.remove(bg);
            isBackgroundDisplay = 0;
        }
    }


    var areOrbitsDisplay = 0;
    var orbits = new Array(8);

    //Creating orbits
    for (i = 0; i < solarSystem.length - 1; i++) {
        var s = solarSystemData[i];
        var geometry = new THREE.TorusBufferGeometry(-(s.position) * planetDistanceFromSun, (s.size * planetSize / 10), 16, 100);
        var material = new THREE.MeshBasicMaterial({color: 0x6897bb});
        orbits[i] = new THREE.Mesh(geometry, material);
        //Orbits are looking down
        orbits[i].lookAt(0, -100, 0);
    }

    function displayOrbits() {
        if (areOrbitsDisplay === 0) {
            for (i = 0; i < solarSystem.length - 1; i++) {
                scene.add(orbits[i]);
            }
            areOrbitsDisplay = 1;
        } else {
            areOrbitsDisplay = 0;

            for (i = 0; i < solarSystem.length - 1; i++) {
                scene.remove(orbits[i]);
            }
        }
    }

    var areAxisDisplay = 0;
    var axisHelper = new THREE.AxesHelper(z);

    function displayAxis() {
        if (areAxisDisplay === 0) {
            areAxisDisplay = 1;
            scene.add(axisHelper);
        } else {
            areAxisDisplay = 0;
            scene.remove(axisHelper);
        }
    }


    //Lights
    var displaySunlight = 1;

    var sunlight = new THREE.PointLight(0xffffff, 1, 10000 * planetDistanceFromSun);
    sunlight.position.set(0, 0, 0);
    scene.add(sunlight);

    var weakLight = new THREE.AmbientLight(0xffffff, 0.1);
    scene.add(weakLight);

    var fullLight = new THREE.AmbientLight(0xffffff, 1);


    function setLight() {

        if (displaySunlight === 0) {
            scene.remove(fullLight);
            scene.add(sunlight);
            scene.add(weakLight);
            displaySunlight = 1;
        } else {
            //Ambientlight
            scene.remove(sunlight);
            scene.remove(weakLight);
            scene.add(fullLight);
            displaySunlight = 0;
        }
    }



    function rotationAroundSun() {

        for (i = 0; i < solarSystem.length - 1; i++) {
            solarSystem[i].position.x += ((solarSystem[i].position.z / solarSystemData[i].speed * speedAdjustment) * time);
            solarSystem[i].position.z += -((solarSystem[i].position.x / solarSystemData[i].speed * speedAdjustment) * time);
        }
    }

    function calculateDistanceAcceleration(state) {
        return state.dValue * Math.pow(state.aSpeed, 2) -
            (g * 1.98855 * Math.pow(10, 30)) / Math.pow(state.dValue, 2);
    }

    function calculateAngleAcceleration(state) {
        return -2.0 * state.dSpeed * state.aSpeed / state.dValue;
    }

    function newValue(currentValue, time, derivative) {
        return (currentValue + time * derivative);
    }

    function selfRotation() {
        for (i = 0; i < solarSystem.length; i++) {
            solarSystem[i].rotation.y += ((rotationAjustment / solarSystemData[i].rotation) * time);
        }
    }


    //Timer
    function incrementSeconds() {
        seconds += 1;
        modelTime += time;
        el.innerText = "You have been here for " + seconds + " seconds, "
            + modelTime + " days according to this model. \n 1 real second = " + time + " model day(s)";
    }

    var cancel = setInterval(incrementSeconds, 1000);

    function speedUp() {
        time *= 2;
        el.innerText = "You have been here for " + seconds + " seconds, "
            + modelTime + " days according to this model. \n 1 real second = " + time + " model day(s)";
    }

    function speedDown() {
        time /= 2;
        el.innerText = "You have been here for " + seconds + " seconds, "
            + modelTime + " days according to this model. \n 1 real second = " + time + " model day(s)";
    }

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(), INTERSECTED;

    container = document.createElement( 'div' );
    document.body.appendChild( container );

    click = false;
    var pn = document.getElementById('pn');
    document.addEventListener( 'click', onDocumentClick, false );
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    // window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseMove( event ) {

        event.preventDefault();
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        click = false;

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }

    function onDocumentClick( event ) {

        event.preventDefault();
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components

        click = true;

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }




    function animate() {

        requestAnimationFrame(animate);

        rotationAroundSun();
        selfRotation();

        controls.update();

        render();
    }

    function render(){

        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects( scene.children );

        i = 0;
        j = 0;

        if (intersects[0]) {
            while (i < solarSystem.length) {
                if (intersects[0].object === solarSystem[i]) {
                    pn.innerText = solarSystemData[i].name;

                    if (click) {
                        console.log(solarSystemData[i].name);
                        newX = solarSystem[i].position.x;
                        while (j < solarSystem.length){
                            solarSystem[j].position.set(solarSystem[j].position.x - newX, 0, 0);
                            j = j + 1;
                        }
                        // camera.position.set(solarSystem[i].position.x, solarSystem[i].position.y, solarSystem[i].position.z + 400);
                        // camera.lookAt(solarSystem[i].position.x, solarSystem[i].position.y, solarSystem[i].position.z);
                        // controls.update();
                        click = false
                    }
                }
                i = i + 1;
            }
        } else {
            pn.innerText = '';
        }



        renderer.render(scene, camera);

    }


    animate();
</script>
</body>
</html>